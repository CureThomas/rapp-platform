/**
 *
 * ██╗ ██████╗ █████╗ ██████╗ ██╗   ██╗███████╗    ██████╗ ██████╗  ██████╗      ██╗███████╗ ██████╗████████╗
 * ██║██╔════╝██╔══██╗██╔══██╗██║   ██║██╔════╝    ██╔══██╗██╔══██╗██╔═══██╗     ██║██╔════╝██╔════╝╚══██╔══╝
 * ██║██║     ███████║██████╔╝██║   ██║███████╗    ██████╔╝██████╔╝██║   ██║     ██║█████╗  ██║        ██║
 * ██║██║     ██╔══██║██╔══██╗██║   ██║╚════██║    ██╔═══╝ ██╔══██╗██║   ██║██   ██║██╔══╝  ██║        ██║
 * ██║╚██████╗██║  ██║██║  ██║╚██████╔╝███████║    ██║     ██║  ██║╚██████╔╝╚█████╔╝███████╗╚██████╗   ██║
 * ╚═╝ ╚═════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝ ╚══════╝    ╚═╝     ╚═╝  ╚═╝ ╚═════╝  ╚════╝ ╚══════╝ ╚═════╝   ╚═╝
 *
 *
 * @brief TCP Server handling incoming connections
 * @class TCPServer
 *
 * Handles incoming TCP Connections by using an asynchronous IO service.
 * It will delegate each new connections to a new TCPConnection object
 *
 * @version 4
 * @date 8-October-2014
 * @author Alexandros Gkiokas <a.gkiokas@warwick.ac.uk>
 * @copyright University of Warwick
 */

#ifndef _ICARUS_TCPServer_HPP_
#define _ICARUS_TCPServer_HPP_
#pragma once
#include "Includes.hxx"

class TCPServer
{
  public:

    /// Create a TCPServer by passing as @param io_service - an asynchronous IO service (see Boost)
    TCPServer ( boost::asio::io_service & io_service )
    : acceptor_( io_service, tcp::endpoint( tcp::v4(), 2222 ) )
    {
        start_accept();
    }


  private:

    /**
     * Start accepting incoming connections
     */
    void start_accept()
    {
        // Create a new connection pointer
        if ( auto new_connection = TCPConnection::create( acceptor_.get_io_service() ) )
        {
            // Give the TCP acceptor, that new connection pointer which will handle everything
            acceptor_.async_accept( new_connection->socket(), boost::bind( &TCPServer::handle_accept,
                                                                        this,
                                                                        new_connection,
                                                                        boost::asio::placeholders::error ) );
        }
        else
            throw std::runtime_error ( "TCPServer start_accept: could not alloc a new TCPConnection pointer" );
    }

    /**
     * Acceptor Error Handler
     * @param 
     */
    void handle_accept (
                         boost::shared_ptr<TCPConnection> connection,
                         const boost::system::error_code& error
                       )
    {
        if ( !connection)
            throw std::runtime_error( "TCPServer handle_accept: null TCPConnection param" );
        if ( error )
            std::cerr << "[TCPServer::handle_accept] Error: " << error.message() << std::endl;

        connection->start();
        start_accept();
    }


    /// Boost asynchronous TCP Acceptor
    boost::asio::ip::tcp::acceptor acceptor_;
};



#endif