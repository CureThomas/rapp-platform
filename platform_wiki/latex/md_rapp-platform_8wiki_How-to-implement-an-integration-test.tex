It is recommended to study on \href{https://github.com/rapp-project/rapp-platform/wiki/RAPP-Testing-Tools}{\tt Rapp-\/\-Testing-\/\-Tools} first.

Basic documentation on \char`\"{}$\ast$$\ast$\-Developing Integration Tests$\ast$$\ast$\char`\"{} can be found \href{https://github.com/rapp-project/rapp-platform/tree/master/rapp_testing_tools}{\tt here}.

A more-\/in-\/depth information on how to write your first integration test is presented here.

The \href{https://github.com/rapp-project/rapp-platform/blob/master/rapp_testing_tools/scripts/default_tests/template.py}{\tt template.\-py} will be used as a reference.

Each integration test must have the following characteristics\-:


\begin{DoxyItemize}
\item Each test is written as a seperate python source file (.py).
\item Each test is implemented as a Rapp\-Interface\-Test class.
\item The Rapp\-Interface\-Test class must define two member methods\-:
\begin{DoxyItemize}
\item execute()
\item validate()
\end{DoxyItemize}
\item The \href{https://github.com/rapp-project/rapp-api/tree/master/python}{\tt Python R\-A\-P\-P Platform A\-P\-I} is used to call R\-A\-P\-P Platform Services.
\end{DoxyItemize}

So lets first create our Rapp\-Interface\-Test class which includes the aforementioned member methods.

```python class Rapp\-Interface\-Test\-: \char`\"{}\char`\"{}\char`\"{} Integration test class \char`\"{}\char`\"{}\char`\"{} def {\bfseries init}(self)\-: pass

def execute(self)\-: pass

def validate(self)\-: pass ```

From the Python R\-A\-P\-P Platform A\-P\-I import the required components. Instantiate a new {\ttfamily Rapp\-Platform\-Service} object and the Cloud Messages that will be used.

```python from Rapp\-Cloud import Rapp\-Platform\-Service from Rapp\-Cloud.\-Cloud\-Msgs import (...)

class Rapp\-Interface\-Test\-: \char`\"{}\char`\"{}\char`\"{} Integration test class \char`\"{}\char`\"{}\char`\"{} def {\bfseries init}(self)\-: self.\-svc\-Client = Rapp\-Platform\-Service() ... ```

Next we need to implement the validation function, {\ttfamily validate()}.

```python def validate(self, response)\-: error = response.\-error if error != \char`\"{}\char`\"{}\-: return \mbox{[}error, self.\-elapsed\-\_\-time\mbox{]}

\section*{Validate Results}

if self.\-valid\-\_\-results == response.\-serialize()\-: return \mbox{[}True, self.\-elapsed\-\_\-time\mbox{]} else\-: return \mbox{[}\char`\"{}\-Unexpected result \-: \char`\"{} + str(response.\-serialize()), self.\-elapsed\-\_\-time\mbox{]} ```

Notice that the {\ttfamily validate()} function has a parameter named response. This is the response object returned from the Platform Service call. It is critical to return validation results as presented above!!

```python return \mbox{[}True, self.\-elapsed\-\_\-time\mbox{]} ```

If the response was succesfully validated,

```python return \mbox{[}\char`\"{}\-Unexpected result \-: \char`\"{} + str(response.\-serialize()), self.\-elapsed\-\_\-time\mbox{]} ```

if the validation failed.

The \href{https://docs.python.org/2/library/timeit.html}{\tt timeit} python module is used to time the execution of the test. {\bfseries This will be deprecated in v0.\-7.\-0 release and execution time of each test will be calculated by the rapp-\/testing-\/core-\/engine.}

Implement the execution function.

The execution function must\-:


\begin{DoxyItemize}
\item Call the, {\bfseries to-\/test}, R\-A\-P\-P Platform Web Service(s).
\item Invoke the validation function.
\end{DoxyItemize}

```python def execute(self)\-: start\-\_\-time = timeit.\-default\-\_\-timer() msg = Qr\-Detection(image\-Filepath='P\-A\-T\-H') response = self.\-svc.\-call(msg) end\-\_\-time = timeit.\-default\-\_\-timer() self.\-elapsed\-\_\-time = end\-\_\-time -\/ start\-\_\-time return self.\-validate(response) ```

You will notice that the above implementation of the {\ttfamily execute()} method calls the qr\-\_\-detection Service!!

```python msg = Qr\-Detection(image\-Filepath='P\-A\-T\-H') response = self.\-svc.\-call(msg) ``` 